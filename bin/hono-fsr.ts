#!/usr/bin/env node

import fs from "node:fs/promises";
import path from "node:path";
import chokidar from "chokidar";
import { discoverAndSortRoutes } from "../lib/discovery";
import { dim, logger } from "../lib/logger";

/**
 * Simple argument parser that supports aliases.
 */
function parseArgs() {
	const args = process.argv.slice(2);
	const options: { root?: string; output?: string; watch?: boolean } = {};

	for (let i = 0; i < args.length; i++) {
		const arg = args[i];
		const [longArg, value] = arg.split("=");

		switch (longArg) {
			case "--root":
			case "-r":
				options.root = value ?? args[i + 1];
				if (!value) i++;
				break;
			case "--output":
			case "-o":
				options.output = value ?? args[i + 1];
				if (!value) i++;
				break;
			case "--watch":
			case "-w":
				options.watch = true;
				break;
		}
	}
	return options;
}

async function generateManifest(root: string, output: string) {
	logger.log(`Starting route discovery in ${dim(root)}.`);

	const discoveredRoutes = await discoverAndSortRoutes(root);
	const outputDir = path.dirname(output);

	if (discoveredRoutes.length === 0) {
		logger.warn(`No routes were found in ${root}.`);

		const emptyManifestContent = `// Auto-generated by hono-fsr, do not edit.

import type { Manifest } from "hono-fsr";

export const manifest: Manifest = [];
`;

		await fs.mkdir(outputDir, { recursive: true });
		await fs.writeFile(output, emptyManifestContent);

		logger.log(`âœ… Empty manifest generated at ${dim(output)}.`);

		return;
	}

	const imports: string[] = [];
	const manifestObjects: string[] = [];

	discoveredRoutes.forEach((route, index) => {
		const moduleAlias = `m${index}`;

		let relativePath = path
			.relative(outputDir, route.filePath)
			.replace(/\\/g, "/")
			.replace(/\.(ts|js|mjs|mts|cjs)$/, "");

		if (!relativePath.startsWith(".")) {
			relativePath = `./${relativePath}`;
		}

		imports.push(`import * as ${moduleAlias} from "${relativePath}";`);

		const objectString = [
			`{`,
			`  filePath: "${route.filePath.replace(/\\/g, "\\\\")}",`,
			`  urlPath: "${route.urlPath}",`,
			`  type: "${route.type}",`,
			`  precedence: ${route.precedence},`,
			`  module: ${moduleAlias}`,
			`}`,
		].join("\n");

		manifestObjects.push(objectString);
	});

	const manifestArrayContent = manifestObjects
		.join(",\n")
		.replace(/\n/g, "\n  ");

	const manifestContent = `// Auto-generated by hono-fsr, do not edit.
// @ts-nocheck

import type { Manifest } from "hono-fsr";

${imports.join("\n")}

export const manifest: Manifest = [
  ${manifestArrayContent}
];
`;

	await fs.mkdir(outputDir, { recursive: true });
	await fs.writeFile(output, manifestContent);

	logger.log(`Manifest generated with ${discoveredRoutes.length} routes.`);
	logger.log(`Manifest saved at ${dim(output)}.`);
}

async function main() {
	const options = parseArgs();
	const { root, watch } = options;

	if (!root) {
		logger.error("The --root (-r) option is required.");
		process.exit(1);
	}

	const defaultOutputPath = path.resolve(
		process.cwd(),
		".hono-fsr",
		"manifest.ts",
	);
	const output = options.output
		? path.resolve(options.output)
		: defaultOutputPath;

	if (watch) {
		logger.log("Watch mode enabled.");

		// initial generation before starting to watch
		await generateManifest(root, output);

		const watcher = chokidar.watch(root, {
			persistent: true,
			ignoreInitial: true,
		});

		logger.log(`Watching for file structure changes in ${dim(root)}...`);

		let debounceTimeout: NodeJS.Timeout;

		const handleEvent = (event: string, path: string) => {
			logger.log(`Detected ${event}: ${dim(path)}. Regenerating manifest...`);

			clearTimeout(debounceTimeout);

			debounceTimeout = setTimeout(() => {
				generateManifest(root, output).catch((err) => {
					logger.error("Failed to regenerate manifest during watch:");
					console.error(err);
				});
			}, 100);
		};

		// only trigger on file structure changes
		watcher
			.on("add", (path) => handleEvent("add", path))
			.on("unlink", (path) => handleEvent("unlink", path))
			.on("addDir", (path) => handleEvent("addDir", path))
			.on("unlinkDir", (path) => handleEvent("unlinkDir", path));
	} else {
		// just generate once and exit
		await generateManifest(root, output);
	}
}

main().catch((err) => {
	logger.error("Failed to generate manifest:");
	console.error(err);
	process.exit(1);
});
