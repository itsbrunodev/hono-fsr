import path from "node:path";
import { pathToFileURL } from "node:url";
import { type DiscoveredRoute, VALID_METHODS } from "./types";

export async function generateRpcTypes(
	routes: DiscoveredRoute[],
	rootDir: string,
): Promise<string> {
	const imports: string[] = [];
	const chain: string[] = [];
	let counter = 0;

	const rootPath = path.resolve(process.cwd(), rootDir);

	const modules = await Promise.all(
		routes.map((route) => import(pathToFileURL(route.filePath).href)),
	);

	for (let i = 0; i < routes.length; i++) {
		const route = routes[i];
		const module = modules[i];
		const moduleAlias = `m${counter++}`;

		const relativePath = path
			.relative(rootPath, route.filePath)
			.replace(/\\/g, "/")
			.replace(/\.(ts|js|mjs|mts|cjs)$/, "");

		imports.push(`import * as ${moduleAlias} from "./${relativePath}";`);

		if (route.type === "middleware") {
			if (module.default) {
				const middlewarePath =
					route.urlPath === "/" ? "/*" : `${route.urlPath}/*`;
				chain.push(
					`.use("${middlewarePath}", ...[].concat(${moduleAlias}.default))`,
				);
			}
		} else {
			// handler
			for (const method of VALID_METHODS) {
				if (module[method]) {
					chain.push(
						`.${method.toLowerCase()}("${
							route.urlPath
						}", ...[].concat(${moduleAlias}.${method}))`,
					);
				}
			}
			if (!module.GET && module.default) {
				chain.push(
					`.get("${route.urlPath}", ...[].concat(${moduleAlias}.default))`,
				);
			}
		}
	}

	const content = `// Auto-generated by hono-fsr, do not edit.

import { Hono } from "hono";

${imports.join("\n")}

const app = new Hono()
    ${chain.join("\n    ")};

export type RpcType = typeof app;
`;

	return content;
}
